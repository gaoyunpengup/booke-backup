npm install 原理
https://mp.weixin.qq.com/s?__biz=Mzg5ODA5MzQ2Mw==&mid=2247484581&idx=1&sn=a857b49008a51cdb1cf5ca8cc75c7163&chksm=c0669c5df711154b88ae171d21e7f4d6b45baa02a254caf069ee1bd4222287145387a86ca289&mpshare=1&scene=24&srcid=0408gyZ56IkMTwKKkP5LyZcc&sharer_sharetime=1586348244150&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd


JS 彻底搞懂的部分
执行上下文，尤其是词法作用域和闭包；

提升、函数和块作用域，以及函数表达式和声明；

绑定——特别是 call、bind、apply 和 this；

对象原型、构造函数和 mixin；

组合和高阶函数；

事件委托和冒泡；

使用 typeof、instanceof 和 Object.prototype.toString 进行类型转换；

使用回调、promise、await 和 async 处理异步调用；

什么时候可以使用函数声明和表达式。

DOM 节点片段和节点缓存

CSS部分
布局——安排彼此相邻的元素的位置，以及如何将元素布置成两列或三列；

响应式设计——根据浏览器宽度大小更改元素的尺寸；

自适应设计——根据特定断点更改元素的尺寸；

特异性——如何计算选择器的特异性，以及级联如何影响属性；

适当的命名空间和类命名

系统设计
渲染——客户端渲染（CSR）、服务器端渲染（SSR）和全局渲染；

布局——如果你正在设计被多个开发团队使用的系统，需要考虑进行组件化，以及是否需要开发团队通过指定标记来使用组件；

状态管理，例如在单向数据流或双向数据绑定之间做出选择。你还应该考虑你的设计是采用被动式还是反应式编程模型，以及组件如何相互关联，例如是 Foo->Bar 还是 Foo->Bar；

异步——你的组件可能需要与服务器进行实时的通信。在设计时需要考虑使用 XHR 或双向调用。如果你的面试官要求你支持旧浏览器，那么你需要在隐藏 iFrame、script 标签或 XHR 之间做出选择。如果没有，你可以建议使用 websocket，或者使用服务器发送事件（SSE），这样会更好；

关注点分离——Model-View-Controller（MVC）、Model-View-ViewModel（MVVM）和 Model-View-Presenter（MVP）模式；

多设备支持——你的实现是否同时支持 Web、移动 Web 和混合应用程序，还是为每一种场景提供单独的实现？如果你正在构建像 Pinterest 这样的网站，你可能会考虑在 Web 上使用三列，但在移动设备上只使用一列，你的设计将如何处理这个问题；

资产文件交付——在大型应用程序中，独立团队拥有自己的代码库是常有的事。这些不同的代码库可能彼此依赖，每个代码库通常都有自己的管道来发布代码变更。你的设计需要考虑如何基于依赖项进行资产文件的构建（代码拆分）、测试（单元测试和集成测试）和部署。你还需要考虑如何通过 CDN 交付资产文件或者内联它们来减少网络延迟。

Web性能
关键渲染路径；

Service Worker；

图像优化；

延迟加载和捆绑拆分；

HTTP/2 和服务器推送的一般含义；

何时预取和预加载资源；

减少浏览器回流以及何时将元素提升到 GPU；

浏览器布局、组合和绘制之间的区别。

来用reduce实现一个map函数吧

实现个二叉树任意两节点间路径的查找吧

跨域解决方案:
node代理服务器
nginx代理服务器
jsonp (JS代码封装)
CORS后台支持
js常见的内存泄漏及解决方法总汇 



PC、H5、Nodejs、小程序、移动端，掌握大前端所有技术栈

能够实现类Element-ui组件库，设计Vue组件

掌握Vue/React源码，MVVM库原理

了解Koa2源码，定制MVC开发框架

前端监控、性能优化、安全

自动化测试、发布、运维


组件设计理念

自定义组件的双向绑定

组件间通信机制

插槽的使用

provide & inject API

实战任务：实现一个element-ui的表单组件


createElement如何构建虚拟dom

React.Component如何实现组件化

setState异步队列

dom的diff算法

render渲染逻辑

React16 fiber架构

React Hooks

实战任务：构建自己的虚拟dom

三次握手和四次挥手详细介绍

TCP 有哪些手段保证可靠交付

URL 从输入到页面渲染全流程

如何预防中间人攻击

DNS 解析会出错吗，为什么

ES6 的 Set 内部实现

如何应对流量劫持

算法：top-K 问题，分成 top-1,top-2,top-K 三小问

webpack 的 plugins 和 loaders 的实现原理

vue 和 react 谈谈区别和选型考虑

webpack 如何优化编译速度

事件循环机制，node 和浏览器的事件循环机制区别

柯里化通用实现和 two-sum 问题

typescript 有什么好处

vue 项目中如何约束 rxjs 数据的类型

rxjs 高阶数据流定义，常用高阶数据流操作符

JWT 优缺点

选择器优先级

基本数据类型

RxJS 冷热流区别

RxJS 调试方法

nginx 负载均衡配置

前端性能优化手段

针对 React 的性能优化手段

301 302 307 308 401 403

vue 的 nextTick 实现原理以及应用场景

vue 组件间通信

谈谈 XSS 防御，以及 Content-Security-Policy 细节

场景题：一个气球从右上角移动到中间，然后抖动，如何实现

场景题：一个关于外边距合并的高度计算

mobx-react 如何驱动 react 组件重渲染

forceUpdate 经历了哪些生命周期，子组件呢?

React key 场景题：列表使用 index 做 key，删除其中一个后，如何表现？

算法：实现 setter(obj, 'a.b.c' ,val)

RxJS 相对于其他状态管理方案的优势？

ES6 特性

闭包和 this 一起谈谈

postcss 配置

Promise 内部实现原理

vuex, mobx, redux 各自的特点和区别

react 生命周期

各方面谈谈性能优化

serviceworker 如何保证离线缓存资源更新

virtual dom 有哪些好处

Vue3 proxy 解决了哪些问题？

Vue 响应式原理

发布订阅模式和观察者模式的异同

图片懒加载实现

css 垂直居中

CI/CD 流程

谈谈性能优化

react 生命周期

key 的作用

hooks

vue 和 react 区别，选型考虑

canvas 优化绘制性能

webpack 性能优化手段

事件循环

如何解决同步调用代码耗时太高的问题

手写 Promise 实现


Promise 实现原理

vue 组件间通信

性能优化

vuex 数据流动过程

谈谈 css 预处理器机制

算法：Promise 串行


CI/CD 整体流程

性能优化

SSR 对性能优化的提升在哪里

vue 组件间通信

react 和 vue 更新机制的区别

Vue3 proxy 的优劣

性能优化

symbol 应用

深拷贝

dns 解析流程

跨域

性能优化

vue 和 react 选型和比较

ssr 优缺点

贝塞尔曲线

Vue3 proxy 优缺点

ES6 特性

Vue 组件间通信

性能优化

ssr 性能优化，node 中间层细节处理


如何编写 loaders 和 plugins

性能优化

webpack 热更新原理

vue 和 react 组件通信

谈谈 eleme 框架源码

用js描述一棵树 √

非递归遍历树 ×

详述js new操作 √

方法调用模式this指向 ×

追问：函数调用模式this指向 √

什么是js闭包 √

如何跨域访问 √

vue的父子组件之间如何通信 ×

用css写无限循环动画 ×

如何响应式布局 √

如何清除float √

手写jsonp √

为什么禁止跨域 ×

osi七层 × 漏说了

tcp三次握手 √ 四次挥手 ×

setTimeout为何能在单线程的js里异步执行 ×

进程和线程的区别 ？

写一个数字转中文的程序 √

js函数中如何绑定this到新对象上 √

bind和call有什么区别 ×

手写快排 ×

讲一下http状态码 √，其中303 304代表什么 ×

死锁的原理和四要素 √

cookie和session的区别 √

同源的定义 √


详述es5 es6中的作用域和闭包 √（es5全局+函数级，函数化闭包，es6块级）

详述输入url到页面渲染完成 √（域名解析-TCP分包-IP寻路-握手-滑动窗口传输-持久化连接-挥手-解析-构建dom树与cssom-构建渲染树-回流-重绘-渲染）

详述js异步机制Event Loop，MacroTask和MicroTask √（1个主线程+n个任务队列，浏览器异步处理后推入队列，循环处理，一个macroTask后跟全部microtask）

Promise.all的用法 √（在所有all中的promise结束后再执行）

如何让Promise.all在抛出异常后依然有效 ×（正确答案：主动reject）

什么是VueX √（状态量跨组件管理）

VueX 中action和mutation的区别 ×（正确答案：同步和异步）

详述Vue的双向数据绑定原理 √（语法糖，dom监听+模型监听）

Vue的优势 √（virtual dom，数据绑定，视图与模型分离，隐去冗杂的dom操作）

如何实现SEO优化 ？（只答了服务器端伪静态）

详述回流和重绘优化 √（回流是对物理尺寸的变更，回流一定会重绘，重绘不一定回流，因此尽量减少回流次数，将元素移出dom树再变更）

详述防抖和节流优化 √（状态锁/同步锁）

简述ES6新特性 √（块级作用域,变量不提升,let, const,箭头函数,模板字符串,promise,async）

简述箭头函数特性 ×

webpack打包如何优化 ×

列举几个css中可继承和不可继承的元素 √

用css选中列表第二项 √

伪类和伪元素的区别 √

h5字体如何自适应屏幕 √

rpx是什么 √

追问：rem是什么 ？

追问：vw是什么 √

追问：vw和rem区别 ×（vw根据屏幕宽度，rem根据根元素确定font-size换算比例）

什么情况下css会使用gpu加速 √

css filter是什么 ×（元素的可视效果例如：模糊与饱和度）

网页如何去适配不同宽度 √

详述meta标签的作用 √

position默认值和所有可能值 √

什么是sass和less √

css动画最小间隔 √

shadow dom是什么 ×

svg和canvas的概念和区别 √

canvas图层怎么用 ×

dom渲染的性能损耗在哪里 √

如何高效地从1000个div中删除10个div √

如何监听img加载完成 √

浏览器里除了js还能运行什么 × (webAssembly和actionscript)

promise有几种状态 × (fufilled, rejected,  pending)

如何捕获promise错误 √

promise可以串联吗 ？答的不清晰

详述vue都能解决什么问题 √

virtual dom如何进行diff操作 ×

vue中data为什么是函数不是对象 √

为什么需要深拷贝 √

简述指针是什么 √

node.js了解吗 × 不了解

进程和线程的区别 √

你自己开发的平台有多少用户和访问量 √

如何监控未处理的异常 ?（只说了监听console error）

5G是什么，为什么要用5G（开放题目）

想象一下5G的应用场景（开放题目）

http和https的区别 √

为什么https不会被截获 √

量子计算机能否破解非对称加密 √（附加）

量子计算机的原理 √（附加）

浏览器如何缓存 ？(答的不好，设置http头部）

详述http 1.0, 1.1, 2.0的区别 √

详述TCP如何保证传输完整性 √

UDP和TCP有什么区别 √

为什么使用UDP × 答的不好

WebSocket是基于什么协议连接 √

冒泡算法和快排时间复杂度 √

分布式系统用什么算法排序 ？半对

广搜和深搜的应用 √

广搜的数据结构 √

链式求导是什么 ×

矩阵的秩是什么 ？半对

梯度和导数，偏导 √

信息熵 √

编译原理 ？半对

sql如何获取当前时间 √

char和varchar区别 √

drop, delete, truncate ？（半对，truncate可以持久化）

python用过吗 ？做过爬虫

作为全栈为什么报前端 √

js用的哪个版本 √

es6新特性 √

promise有几种状态 √

promise如何满足多个异步进程的同步顺序 √

promise.race和promise.all的区别 ×

怎么设计页面布局（开放题目）

如何用flex让8个图标排成两行 ×（flex-wrap）

垂直居中和水平居中 ×（说反了）

你的页面是用一套界面响应不同宽度吗 √

自己如何调前后端api √

vue中的fetch和axios是什么×

跨域问题怎么解决 √

跨域怎么做post ×（用iframe）

详述git操作 √

vue.js 加载完成前隐藏花括号 ×（v-clock）

开发主要用react，有兴趣转技术栈吗（有）

可以实习多久

纯js如何获取scrolltop值 √

详述js闭包原理和意义 √

深拷贝 浅拷贝是什么 √

arguments如何转数组 √

移动端和pc端click事件为什么差了300毫秒 ×（因为iphone可以双击缩放）

flex布局用法 √

如何实现移动端响应式布局 √

ES6的作用域 √

async await是什么 √

块级作用域有哪些 √

详述promise异步机制 √

如何实现跨域访问 √

http通信如何设置缓存 √

详述http状态码 √

如何实现vue组件通信 √

简述VueX的作用 √

如何实现一个swiper √

hybrid是什么 √

hybrid js如何调用native接口 ×

为什么要做前端

对于自己的发展规划

上海怎么样

块状元素 行内元素 √

标签语义化是什么 √

css清除浮动 √

什么是盒模型 √

css优先级 √

position属性 √

移动端适配？（媒体查询，flex，rem）还有viewport

px em rem √

==和===的区别 √

原型和原型链是什么 √

什么是深拷贝 √

什么是同步 什么是异步 √

如何顺序执行10个异步任务 ？（答的不全）

es6 proxy是什么 ？（不了解，说了下代理模式的概念）

题目：遍历一个任意长度的list中的元素并依次创建异步任务，如何获取所有任务的执行结果 ？（用promise.all，感觉面试官不是很满意，应该是用proxy代理）

对一个对象数组排序 ？（增加原型方法）

乱序一维数组排序

数组去重 ？（map.set，键值对象）

如何进行git的分支管理 ？（答的不全）

浏览器有哪些缓存 √

什么是跨域 √

如何解决跨域 √（jsonp，代理，白名单）

不考虑还有别的办法 √

补充 本地存储，window.name，form.message

页面性能的优化 √（重绘，回流，防抖，节流

还有吗 √（懒加载，预加载）还有base64，压缩，骨架屏

浏览器安全处理 √（xss，数据库注入）还有csrf，文件上传漏洞

有没有真机浏览器debug经验（开放题）

ml

如何在移动端处理兼容性 ？（css前缀）

追问 工程中遇到过类似的问题（svg）

追问 还有补充吗（没了…）还有meta viewport http-equiv

vw em rem的区别和使用场景 √

不同定位模式之间的区别 √

fix的显示问题？（宽度塌陷）没答全，还有z-index覆盖

canvas如何使用图层 √

追问 如何避免图层覆盖 ？（答的封装）

css

所有绝对居中的实现 ？( flex, text, padding: auto）没答全，还有translate

sass和less有什么区别 √

实现响应式布局的方法 √ (flex 媒体查询 rem)

追问 还有吗 √ (grid)

了解过BFC吗 ×（不了解）

js

用三句话概括所有值传递类型，所有引用传递类型，以及如何用引用的方式传递值类型 ？

js所有基础类型 ？（布尔值，数字，字符串）还有null和undefined，symbol

追问 null和undefined的区别 √（未定义和赋空值）

追问 怎么比较 ×

指针和引用的区别 √（地址和别名）

js当中对于不同环境的变量什么时候释放 √（标记清除和引用计数）

追问 在非闭包的情况下变量什么时候会被回收？（不确定）

js的作用域你怎么理解 √

js里的多重继承怎么实现 √（call，es6 extend)

追问 还有吗？（不知道）

React 和 Vue 生命周期有什么区别？（答了vue，react不了解）

Vue如何监听数据的变化 √ (defineProperty，订阅者模式)

Vue里如何实现父子组件之间的通信 √

了解过高阶组件吗（不了解）

看过Vue的源码吗（目前主要在理解原理阶段）

有没有使用工具构建过工程项目（vue cli+webpack）

webpack编译和构建原理（分析依赖，chunk）没有说loader

平时使用什么工具转换es6（babel）

babel转码流程（配置.babelrc，解析语法数，改变块级变量名等等）

js哈希存储结构的构成方式 √（哈希值，哈希表，哈希冲突）

js当中如何实现某一个数的阶乘 ？（只答了for循环）

设计一个算法找到乱序数组中相加等于指定值的所有数对 √（快排+两端查询 / 两层for）

介绍一下你的项目（中大型小程序系统，企业控制台，Vue CLI单页面web应用等）

你的小程序是怎样一个软件（校内交易社区）

追问 为什么不通过闲鱼去卖呢（解决楼内交易）

你的小程序用openid去登陆，可以讲一下OAuth流程吗（可信平台对前端发放token，后端处理敏感信息）

追问 OAuth有什么优势（避免前端直接接触敏感信息）

你的小程序Websocket通信系统是做什么的（各种类型消息的实时通信）

追问 你的实时语音通信是怎么做的（接口鉴权->手势状态机->本地持久化->上传服务器->缓存管理）

追问 微信的录音返回数据是传回base64吗（不是 是返回tmp协议路径）

追问 你的录音本地持久化的目的是什么（减轻服务器负载，减少冗余的资源重传）

追问 你的本地持久化是怎么做的（用local storage）

追问 你的一条语音大概有多大（几十k到几百k）

追问 小程序的localstorage有多大（10-20M）

追问 你的websocket为什么要做心跳（避免网络环境变化带来的通信中断）

追问 你的心跳机制是怎么做的（计时器控制 超时重连 网络状态监听）

你是自己买的服务器吗（阿里云）

你的CDN服务是怎么做的（阿里云）

你的SSL是怎么做的（配置ssl证书链，非对称加密）

你的搜索为什么用Elastic Search（中文分词，倒排索引，高效）

追问 你的中文分词搜索是怎么做的（IK分词器）

你的数据库用的是什么引擎（INNODB）

追问 为什么用INNODB引擎（外键，索引类型，utf8mb4）

追问 INNODB的锁是什么粒度级别（答的表级，不太确定）

追问 对于事务的原子性有了解吗（不了解）

你的单页面web应用是怎么做的（Vue CLI+Webpack自动构建，Vue Router路由）

你的用户密码是怎么存在数据库里的（PASSWORD函数）

追问 用户密码在前端传输的时候有做加密吗（有了ssl不需要）

你有没有做登陆态持久化，怎么做的（设置cookie过期时间）

追问 你的服务器端怎么管理session登陆态（php自动分发）

追问 怎么在多台服务器同步session数据（数据库或者分布式系统）

追问 分布式怎么做（hbase或者es）

追问 存储完以后怎么用php获取呢（不知道）

在中航通用实习的主要成果（独立开发web系统，数据控制台，后端服务器）

追问 你的控制台管理什么数据（产品，新闻，职位，简历）

追问 你的WYSIWYG编辑器是自己做的吗（基于summernote二次开发）

追问 你的异步交互和事物存储是什么（AJAX+PDO）

你对于自己未来发展的规划是什么样（读框架源码-写自己的框架-掌握前后端深层知识-掌握整个软件架构）

XSS，CSRF，数据库注入怎么防范（控制前端渲染，控制后端处理，预编译）

解释一下深拷贝和浅拷贝（引用传递和值传递blablabla）

平时自己是怎么关注前端领域的知识的（工具书，技术博客，官方文档，交流群）

介绍一下你的项目经历

影响页面加载性能的主要因素 √

你是怎么统计页面数据的 √

补充 其实这些数据可以用小程序控制台查看

你的微信OAuth登陆怎么做的 √

你的微信模板消息怎么做的 √

小程序的分包原理是什么×（用户点击时加载对应包）

如何自动构建前端项目并自动部署？（webpack+第三方插件自动化）

视差屏原理 √

追问 用absolute和translate做视差哪个好 √

追问 你的vue项目里为什么用了jquery，用在哪 √

数组有哪些方法 √

函数bind方法会接收什么，返回什么 √

哪些静态资源会阻塞页面渲染，怎么解决，有什区别 √

如何跨域访问 √

JSONP原理 √

事件代理原理 √

你现在的实习主要做什么

能接受加班吗 以及能接受的加班时间

为什么选择美团

js有哪些基础类型√

闭包是什么√

如何循环间隔1秒输出数组元素√

如何实现事件监听√ (callback，addEventListener)

追问 两者有什么区别√ (后者会被覆盖)

Vue生命周期√

BFC了解吗× 块级格式化上下文

画一个盒模型√

追问 box-sizing√

实现一个三栏布局√

websocket原理√

登陆的cookie怎么存的√

把 www.toutiao.com转为 com.toutiao.www√

介绍一下你的项目经历

你的php包管理用什么√ composer

composer的autoloader怎么实现的？

php fast-cgi是什么？并发管理

php setcookie是否会改变$COOKIE数组√不会

你的MYSQL Procedure是干什么的√函数交互

跨域请求怎么设置header字段√

Vue Router原理√

VueX具体应用在哪些场景内√

用过哪些Ajax组件√ Axios

Axios怎么实现拦截√

js二维数组反向合并√

js驼峰转换√
考虑效率(为啥正则效率低)
输入：
contentType

输出：
content_type

介绍一下你的项目经历

给我看看你上线的小程序√

追问 这里瀑布流不平衡怎么回事√（用10px显示误差换取预加载带来的性能提升）

追问 服务器用的什么√（阿里云腾讯云都用）

追问 服务器运维了解吗√

追问 服务器宕机以后怎么解锁mysql×（工程中没有遇到，不确定）

追问 cpu使用率异常升高怎么解决√

描述一下你的小程序开发流程√

你的websocket是干什么的√

追问 你的websocket是怎么通信的√

离线怎么获取消息√

Vue Router原理√

你的发展规划（前端工程-前端架构-系统架构）

你的意向部门（C端）

问 有可能去哪个部门（不确定，双向选择）
性能上面做过优化效果最好的（懒加载，预加载）

追问 在什么情况下判断预加载（点击时利用150ms延迟进行预加载）

追问 还有其他情况会用预加载吗（没有用过） 这两个是你认为最明显的吗×（严重失误，忘记说重绘和回流以及防抖和节流，浏览器缓存，代码压缩，异步加载等等）

其他方面比如构建 组件化的拆分做过吗 

整理中

性能优化
http缓存
做过的有特点的项目
遇到的问题与解决方案
toB和toC的区别
现场面对客户的经历
前端安全相关(着重中间人劫持)
为什么跳槽
职业规划
有什么问我的(团队简介、前端参与项目的过程)

项目开发流程
对vuex的看法
vue从data改变到页面渲染的过程
介绍状态机
组件设计原则
怎么看待组件层级嵌套很多层
前端安全防范措施
介绍oauth
怎么看待virtual dom
对flutter的了解
weex和rn原理
大屏用的技术
大屏数据来源与管理
websocket的使用场景
pwa的使用
对http2的了解
对新技术的了解
职业规划
为什么想来腾讯
有什么问我的（团队协作方式、技术积累、对我的期待）

介绍项目特色与难点
性能优化
对MVC MVP MVVM的了解
对SEO的了解
做了道逻辑题
国内前端行业的发展
有什么问我的（团队名称的意义、团队的业务、如何定位前端在设计团队的角色）

Vue遇到问题和解决(上)
https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485066&idx=1&sn=1c5543f4ed430460e0125f5d61296cc4&chksm=ea0165e6dd76ecf0c55c06a5c07430ec9671a34a0e29d9c18318607b05699bc481bc787f9a54&mpshare=1&scene=24&srcid=&sharer_sharetime=1583369320481&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd
Vue遇到问题和解决(中)
https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485079&idx=1&sn=6c687104e1edf44baf8464847e236cb3&chksm=ea0165fbdd76ecedcebcff21a98622b175e45f22b1ac3c6e7cf24b4d24ba02ec888486948b2a&scene=126&sessionid=1587113740&key=4bc1bbadb5ce2652d770b49424e2a5c4727e9f2e5a51ec3b81bc740ab7a7bd885093f2dfe9d9ad365fb767417bc723ca793040fe27b47120ef4227e3e277e4dddd8b01e429b6159c33f6711f13fcda34&ascene=1&uin=MTA1MzAzOTQ0MA%3D%3D&devicetype=Windows+7&version=62080079&lang=zh_CN&exportkey=AY6Kg%2FuqjLBkNk95PpLfu2E%3D&pass_ticket=8PzyIVrEliE6HC6AUFbIO0PKkw%2BhOOPOAaLg3iau1dmA1va8mnsZU8DJwKzoqGAg

执行上下文和执行栈
https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485112&idx=1&sn=23681854aaf792bff91d917363e46f62&chksm=ea0165d4dd76ecc2468abb7336d9b5b2f2f4630e6883d2f8ad7bf89b97a1c698a9c0a6dde360&scene=126&sessionid=1587113661&key=0bede9ac882f25ac9b54817c60b48f3e3b50fbc889d20c316191ad0034cb4e7cbf837b22160347bb66f9d68f017953edaa547fb301779b1e3599b36a3e5691e16732649cb33ee4a44dc6a68e8c7b16a9&ascene=1&uin=MTA1MzAzOTQ0MA%3D%3D&devicetype=Windows+7&version=62080079&lang=zh_CN&exportkey=AYMPvUs0lKi%2Bo%2F0Gu2Hfuz8%3D&pass_ticket=8PzyIVrEliE6HC6AUFbIO0PKkw%2BhOOPOAaLg3iau1dmA1va8mnsZU8DJwKzoqGAg

git常用
https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485084&idx=1&sn=3283edf99b322a84b1dbbcabebb9e339&chksm=ea0165f0dd76ece67cc52fda437bd0fe5a5b5a2611ed16691788cc0fcc82ef2185e2675ce3bb&mpshare=1&scene=24&srcid=&sharer_sharetime=1584071873248&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd


Webpack面试
https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247485446&idx=1&sn=44e1854d1a082d2d3dbed728cbc2661b&chksm=ce6eccaaf91945bce11a50b5805b2826b388aba0df365cbfbac1a6a928ad54233c17f1b1a20d&mpshare=1&scene=24&srcid=&sharer_sharetime=1585282968866&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

CSS原理
https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247485459&idx=1&sn=4f437ea12f9bb3daeaf9799f75b2ebc2&chksm=ce6eccbff91945a9491389daa997c7c615b9ce2bb4fa8e068f358038dfd2ed614af1dab470c9&mpshare=1&scene=24&srcid=&sharer_sharetime=1585617663480&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

https://mp.weixin.qq.com/s?__biz=MzIxNjgwMDIzMA==&mid=2247485308&idx=1&sn=9ddb365a857d1c5d1f93a8b45baebfd7&chksm=9782c9f5a0f540e3fc927212179fdee2b38d431a6c898d82a5f164b8e7b412bf37c7d6e94294&mpshare=1&scene=24&srcid=&sharer_sharetime=1586499906927&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

JS引擎运行机制
https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247486177&idx=1&sn=a6786f9a8f7161f87659c4b9a047190a&chksm=97c5974fa0b21e5979208ea40472452da3833ae2de0edd93549e0b0e2fb8ff4e42e5851f3ecb&mpshare=1&scene=24&srcid=&sharer_sharetime=1585887413996&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

jwt全解
https://mp.weixin.qq.com/s?__biz=MzIxNjgwMDIzMA==&mid=2247485286&idx=2&sn=928bb5be09195839694637ee0d9b9e66&chksm=9782c9efa0f540f9a263a7cca78506866b06fdc51e94417de6af0ecb818de3a57429c3e71ca7&mpshare=1&scene=24&srcid=&sharer_sharetime=1586062588148&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

1、前端浏览器输入URL后发生什么？
普通前端会回答，dns解析，获取html文件，解析DOM，渲染页面这么一个流程。

其实过程复杂的很，比如一个dns解析阶段，它分为哪几步？解析的ip一定是一样的吗？每次都会进行dns解析吗？可能还需要了解cdn托管的一些问题。

比如html文件获取，它是如何传输的？如何建立链接的？三次握手、四次挥手是什么？http协议端口是什么？为什么直接能访问一个html文件？

....

2、前端性能优化？
大多数前端，基本会说，减少http请求、压缩合并js以及css、图片懒加载的技术、防止回流和重绘、css放头部、js放底部。

以上的说法对吗？完全正确！可是在这个过程中，我觉得缺少一种思考。

比如减少http请求，可以从哪些维度上减少呢？比如合并http请求？比如合并资源？比如图片懒加载？http还有其他维度的优化吗？cookie优化？http请求和资源加载的区分优化？在webview中呢？和普通的浏览器的优化技术，又有什么区别？

......

3、前端如何做性能监控、异常监控？
性能监控，异常监控，基本在小公司，是没有实践基础的，可是在差不多的大厂中，他们会关注这个问题。

首先是性能监控，应该从这么几个维度来说：一个是http的方面，在后端log日志，流入kafka，然后在kafka消费数据，可以准确的监控到哪些接口有异常？异常率是多少？另一个方面，是前端的 Performance 的api，在用户的实时使用的过程中，就会产生数据，这样就能实现页面性能监控。

前端异常监控，首先要明白什么是异常，html、css这些东西，无非就是一个展示的问题，还不至于让页面白屏的事情发生，所谓的异常监控，其实就是js的异常监控。在前端领域，window.onerror是进行js异常的监听事件。并且要知道，它在IE中，是不支持的，所以IE的监控，要使用try catch 的方式进行捕获，比如我们可能还要注意到，遇到异步的时候，这个如何做try catch的异常捕获。

最后一个是前端sdk埋点，直接开发一个js文件，统计用户的UV/PV分析等等，比如用户的转化率之类的，这一块个人没有什么特别的实践，各位可以在网上百度看看。

4、前端安全方面
这是一个高级前端必问的问题，说的是一个前端对整个前端安全的系统认知。

我们必须理解这么几个方面：sql注入、xss、csrf、cookie安全、密码安全等等。

sql注入，要理解sql注入的场景，它的原理是什么，当前的数据库的解决方案是什么？

xss攻击，常见的攻击场景，什么类型的网站容易被xss攻击，整个流程的原理是什么？

csrf攻击，其实就是一个钓鱼网站，要理解为什么会收到攻击，应该采取什么策略进行防御。

cookie安全，要理解为什么用token，优势等。

密码安全，主要是用户登陆，用户数据提交，加密，存入数据库的一整个流程。

其次，其实还有http和https的问题等等。

5、http、https、http1.0、1.1、2.0、3.0的区别
http这一块，其实是一个非常复杂的体系，要深挖的东西特别多。

http进行非对称加密，得到https，这个过程是怎么样的？什么是CA证书？整个网站进行验证的流程是什么？

http各个版本的区别是什么？解决了哪些问题？比如头部缩减的优化，那你了解这个优化的具体策略吗？缩减了什么？又增加了什么？要深挖细节。

http的底层协议？tcp/ip协议的三次握手，四次挥手，具体是怎么通信的？什么叫满启动？甚至延伸到整个网络协议的领域，什么是socket？udp是干什么的？dns解析？ftp？以及不常用的其他协议？

如果再进行扩展，计算机网络的7层结构？每一层做了什么事情？计算机组成原理，如何解析我们的代码等等。

......

深度解读
这一部分，我大致分了几个模块，源码、可视化、跨平台、工程化、混合app交互、设计模式，其实每一个都值得前端去研究。

作为个人，其实也算是我定了几个方向，自己以后要努力的地方。

1、源码
最好要读一读某个框架的源码，最不济，也看看别人写的源码解读的文章，现在的趋势，基本是以react、vue为主。

以vue为例，你得懂vue框架的整个周期，比如vue的初始化，发生了什么？vue的模板解析，是如何进行的？如何形成AST？render函数的生成？什么是依赖收集？什么是patch？数据更新策略等等。

你也要懂得在这个过程中，混入mixins、$options，vuex、router他们各自如何通过这些api，实现各自的功能？

源码的维度，可以试着从vue的体系、react体系、loadash、zepto这些库中下手，因为我们就是从这些框架以及js库，走过来的。

2、可视化
地图、echats、canvas、webgl、d3.js、three.js！

上面是个人想要研究的关于可视化的一个个主题，虽然可视化不是本人的专长，可是因为之前在地图相关的公司待过，也算是沾了可视化的一点光。在面试饿了么的过程中，就提到了一个特殊的使用场景，就是关于地图的线路绘制，大批量数据的推送，以及性能相关的问题。

以后，普通前端的技能，比如vue、react等等，大家都会，没有什么差异化的竞争，前端市场趋于饱和，更需要的是在某些方面专精的人才。

3、跨平台
flutter、react-native、weex、electron

这是目前市场上，针对跨平台的一些解决方案，每一个框架，大致方向上，都解决了一定程度上的多端开发能力。

首先需要明白的是，多端开发并不是万能的，也有一些我们开发中的痛点，无论rn、还是weex，都是给前端提供一些特殊的组件，实现开发能力。但是业务是多样的，需要也是多变的，对于没有提供的组件，或者api，我们前端开发人员，有些功能是没办法实现的。

对于多端框架，更重要的是理解层面的东西，比如electron，就是要理解它的本质，就是使用node塑造一个桌面应用的容器，然后内部是一个webview。

从面试的角度，面试官重视的不是这个东西怎么用的问题，一般会问一些内部原理，比如小程序和公众号的对比？底层实现方式？比如rn的编译解析过程是什么？如何把js编译为真正的ios、android应用。比如flutter的渲染机制，和rn这些渲染方式有什么不同？和普通的web网页又有什么区别？

跨平台技术，flutter最近比较火，从找工作的角度，其实可以学学。electron这些桌面应用，本身不难，但是学过和没有学过，其实本身就是一种差异。

4、工程化
工程化这一块，是个人比较感兴趣的一个方向。自己也做过一些实践，但是只能说是工程化中的冰山一角。

抛砖引玉，提一些我们可以探讨的点。

1、前端项目标准？

表现为库的选择？文件划分目录的规定？pc、mobile多端实践？ssr方案集成？

2、组件库集成？

组件库建设的目的？npm包的发布？

3、脚手架工具？

webpack编译优化？webpack打包构建优化？自我脚手架的工具使用？

4、git提交规范commit-msg？代码检查规范eslint？

5、前端性能监控？前端异常监控？前端用户埋点sdk？

6、rap？jenkins？

5、混合app交互
jsBridge、性能提升方面、x5内核

算是一个小的模块吧，我们得明白，jsBridge是如何做到h5和原生应用的交互？

ios和h5的交互通信？window.webkit?是否同步？

android和h5的交互？细节和ios有什么不同？

webview在性能提升方面，可以做哪些？什么是离线包？

腾讯x5内核的优势是什么？我们用了x5内核，可以避免什么问题？

6、设计模式
最后谈谈设计模式，算是一个高频的面试题。

我们至少要知道以下这些设计模式的功能、代码实现、使用场景问题。

单例模式、原型模式、工厂模式、观察者模式、策略模式、代理模式等等

盒模型（标准 & IE ）

flex、float、Normal Flow 等的理解

CSS 常用选择器

行内、内部、外部样式的区别

CSS 层叠规则

BFC 与 IFC 的了解

CSS3 的 transform、transition、animation 等属性的运用了解

响应式布局的理解

类型转换

this

作用域（作用域链）

原型链以及继承

闭包的理解

动态作用域和词法作用域

JavaScript 执行机制

promise & async

响应式的基本原理是什么

发布订阅模式的理解

Virtual DOM 的理解

前端路由的实现原理

nextTick / setState 的实现原理

diff 算法

单页面应用（SPA）的原理和优缺点


模板和渲染函数的弹性选择

简单的语法和项目配置

更快的渲染速度和更小的体积

更适合大型应用和更好的可测试性

同时适用于 Web 端和原生 App

更大的生态系统，更多的支持和好用的工具

浏览器缓存机制

浏览器中 JavaScript 的执行机制

页面渲染原理

浏览器安全问题

浏览器为什么会跨域

如何系统的优化页面

HTTP 与 HTTPS 的区别

TCP/IP 协议

三次握手和四次挥手

CDN 的作用和原理

正向代理与反向代理的特点


理解 Babel、ESLint、webpack 等工具在项目中的作用

Babel 的核心原理

Webpack 的编译原理、构建流程、热更新原理

nginx 的基本理解

理解 Git 的工作流程

Mock 的意义及优点

前端性能衡量指标、性能监控（performance,LightHouse）

常见的性能优化方案有哪些

SSR 方案的性能优化

Webpack 的性能优化方案

React、Vue 等框架使用性能优化方案

网络层面的优化方案

页面渲染层面的优化方案

白屏的优化方案

Nodejs 在应用程序中的作用

Express 和 Koa 的区别

Nodejs 的底层运行原理、和浏览器的异同

Nodejs 非阻塞机制的实现原理

性能优化
https://mp.weixin.qq.com/s?__biz=Mzg5ODA5MzQ2Mw==&mid=2247484602&idx=1&sn=4d7e1b83d559db052c4da3fc205674bd&chksm=c0669c42f71115541234d50b094005f9019c432579884ed623d8bf3141b103ae3245ed63ec23&mpshare=1&scene=1&srcid=04179yPyIe3GvKB1LmpBfr5Q&sharer_sharetime=1587101824932&sharer_shareid=f619f4d227e5fc241d9e0e8d8506d7bd&key=0bede9ac882f25ace8c54c9dc3b90eaa9ac1657788f8097eef08fcd9019d791b22134838796240dade3fdd0e59516e38fb58c52c03c6bd333c7d905adb1f2049fc3a93d199079cff810fce7e4796e23f&ascene=1&uin=MTA1MzAzOTQ0MA%3D%3D&devicetype=Windows+7&version=62080079&lang=zh_CN&exportkey=AX44423GwVH%2BrUWKa%2FS3Z80%3D&pass_ticket=8PzyIVrEliE6HC6AUFbIO0PKkw%2BhOOPOAaLg3iau1dmA1va8mnsZU8DJwKzoqGAg


Rest FUl api
https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247489389&idx=1&sn=aab16e6de3c1b40bfb12d1b2c31dc64c&chksm=fa4968dccd3ee1ca273fa5fa90f10d4044f97dbc64de57bc1e2b2e6f74490568ceaa5ce2f347&mpshare=1&scene=1&srcid=&sharer_sharetime=1587121167823&sharer_shareid=cfcd208495d565ef66e7dff9f98764da&key=4e333be95d49052edb37a3b6e7f4b0e1d6715a3df45133ddabf9d982b3ff3173f5332490be366d831c1c2907c30cc7e9c1e1ae1e7fd35845c8e51187c8a48a5fe3972437cc83a2eeb534ef704d734159&ascene=1&uin=MTA1MzAzOTQ0MA%3D%3D&devicetype=Windows+7&version=62080079&lang=zh_CN&exportkey=AZfV8rPORicGFelZOrgsX7c%3D&pass_ticket=8PzyIVrEliE6HC6AUFbIO0PKkw%2BhOOPOAaLg3iau1dmA1va8mnsZU8DJwKzoqGAg


盒模型（标准 & IE ）

flex、float、Normal Flow 等的理解

CSS 常用选择器

行内、内部、外部样式的区别

CSS 层叠规则

BFC 与 IFC 的了解

CSS3 的 transform、transition、animation 等属性的运用了解

响应式布局的理解

HTML 语义化( 不是很理解为什么面试总会问 )

canvas

本地存储（ localStorage、sessionStorage、cookie 的理解 ）

video 和 audio 的使用

应用缓存( cache manifest )

类型转换

this

作用域（作用域链）

原型链以及继承

闭包的理解

动态作用域和词法作用域

JavaScript 执行机制

promise & async

响应式的基本原理是什么

发布订阅模式的理解

Virtual DOM 的理解

前端路由的实现原理

nextTick / setState 的实现原理

diff 算法

单页面应用（SPA）的原理和优缺点

了解的知识点:
浏览器缓存机制

浏览器中 JavaScript 的执行机制

页面渲染原理

浏览器安全问题

浏览器为什么会跨域

如何系统的优化页面

HTTP 与 HTTPS 的区别

TCP/IP 协议

三次握手和四次挥手

CDN 的作用和原理

正向代理与反向代理的特点

理解 Babel、ESLint、webpack 等工具在项目中的作用

Babel 的核心原理

Webpack 的编译原理、构建流程、热更新原理

nginx 的基本理解

理解 Git 的工作流程

Mock 的意义及优点

前端性能衡量指标、性能监控（performance,LightHouse）

常见的性能优化方案有哪些

SSR 方案的性能优化

Webpack 的性能优化方案

React、Vue 等框架使用性能优化方案

网络层面的优化方案

页面渲染层面的优化方案

白屏的优化方案


Nodejs 在应用程序中的作用

Express 和 Koa 的区别

Nodejs 的底层运行原理、和浏览器的异同

Nodejs 非阻塞机制的实现原理

Vue3响应式和以前的区别?
https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247486221&idx=2&sn=843b26f75b47cadf4c5423a83122869f&chksm=97c596a3a0b21fb53867461054afa09034c004e6ce07d84f56bf92180e42225257ad888955d4&mpshare=1&scene=24&srcid=&sharer_sharetime=1586838916210&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

Vue计算属性如何实现缓存
https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485217&idx=1&sn=591bf1b802e68807174febc8d514d31a&chksm=ea01644ddd76ed5b8045c2c7d88dac2dd62adecc0b23daf45f5f325d1ae3551cd703047ef858&mpshare=1&scene=24&srcid=&sharer_sharetime=1586934488257&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd

前端大面试
https://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&mid=2650078441&idx=1&sn=ab260bdd95fabe2e21092e2a8214a453&chksm=83da618cb4ade89a660ac2426e39b65261c0639e60dcc0b859c4971db5cb68f95702611228a4&mpshare=1&scene=24&srcid=&sharer_sharetime=1587015137903&sharer_shareid=00b9e8e269d106c4b0d34d35a520f9ad#rd





React优点:
(1) 组件化开发
(2) 虚拟DOM,
(3) 提供合理的钩子函数, 让开发者定制去处理某些需求
(4) 采用JSX语法进行编写, 可以让HTML标签直接嵌入在JS的分支和循环流程里
(5) 跨平台推出了React Native框架
(6) react-dom/server支持服务端渲染react项目
React缺点:
(1) 需要熟悉JSX语法的编写
(2) 建议配合脚手架使用, 需要掌握webpack和路由以及redux的使用
DocType作用?
<!DOCTYPE> 声明位于文档中的最前面，处于 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档

严格模式与混杂模式?
(1): 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。
(2): 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作
(3): OCTYPE不存在或格式不正确会导致文档以混杂模式呈现

HTML5的离线储存？
localStorage 长期存储数据，浏览器关闭后数据不丢失；
sessionStorage 数据在浏览器关闭后自动删除。

如何实现浏览器内多个标签页之间的通信?
调用localstorage、cookies等本地存储方式, 或者url传值方式

webSocket如何兼容低浏览器？
Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于长轮询的 XHR(AJAX)
介绍一下CSS的盒子模型？
（1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;
标准盒模型 content部分只有width
（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).

CSS可以继承和非继承的样式名字?
可继承的样式： font-size font-family color, UL LI DL DD DT;
不可继承的样式：border padding margin width height ;
CSS优先级计算?
!important > 内联 > id > class > tag

为什么margin: auto; 不能垂直居中?
auto作用: auto表示两种情况：占用可用空间或0 px
子元素width: auto; 相当于width: 100%, 所以margin: 将被设置为0px;
只有width / height / margin 可以设置为auto
结论:

水平方向宽度默认是父级元素的100%，前提给宽度设置一个固定值，左右margin为auto，可以平分剩余空间
垂直方向默认是内容高度，与父级元素的高度没有直接的关系，w3c规定, 除了定位元素外, margin-top / margin-bottom 都为0
图片使用margin: 0 auto; 为什么不能水平居中?
因为图片/行块元素, 都是靠内容撑开宽度, 不去按照父级宽度, 分配剩余宽度, 所以auto被重置为0

css中 transparent 什么作用?
等同于 rgba(0, 0, 0, 0), 真彩色, 效果是 透过屏幕看后面的颜色

通函数和箭头函数区别?
this关键字指向: 普通函数指向调用者/要指向者(new/apply/bind/call), 箭头函数指向上一层作用域this(永不变, 无法被修改, 或new)
箭头函数不能作为构造函数, new
箭头函数没有arguments, 使用...剩余参数运算符替代
箭头函数没有pro概念totype原型属性
箭头函数不能用作Generator函数
cookies，sessionStorage 和 localStorage 的区别？
存储方式	存储空间	存储时间	与服务器交互
cookie	4KB	可设置(默认关闭浏览器)	默认携带
localStorage	5MB	一直在(除非主动删除)	不携带, 只存在浏览器本地
sessionStorage	5MB	不可设置(默认关闭浏览器	不携带, 只存在浏览器本地

Vue中常见的指令有哪些?
v-bind
v-on
v-if / v-else / v-else-if
v-show
v-model
v-for
v-once (只渲染一次)
v-text / v-html
Vue中常见的修饰符有哪些?
.stop (阻止事件冒泡)
.prevent (阻止默认事件)
.self (只有当前标签才可以触发此事件)
.once (这个事件只执行一次)
.sync (可以更新props执行的父级变量)
.number (把数据直接格式化成number类型赋予给变量)
.lazy (当失去焦点才绑定数据)
.trim (去除两边的空格)(不会去掉中间的空格)
.capture (事件捕获阶段 ,触发此事件).
.passive (1. 提高移动端滚动效率(实时触发), 2. 内置了prevent, 不要再调用了)
$nextTick()的作用?
在下次 DOM 更新循环结束之后执行延迟回调
$nextTick要放入回调函数

axios是什么? 怎么用?
Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中
(1): npm 下载axios模块
(2):二次封装axios 全局网络请求工具, 配置不同的域名请求
(3): 统一的接口管理文件, 所有的请求都在那里配置.

MVVM是什么, 说说你的理解?
它是由MVC设计模式演变过来的一套设计模式,它将视图UI与业务逻辑分开, 使用View-Model层把View和Model绑定在了一起, 互相影响, Vue就是采用MVVM的设计模式

Vue和JQuery的区别? 使用场景?
Vue: 靠数据驱动视图, 基本上无需获取DOM和设置DOM.
JQuery: 获取DOM节点, 操作节点/和数据
使用场景: 数据变化比较多的时候(Vue), DOM节点操作比较多(JQuery)

Vue生命周期图解?


vue如何监听键盘事件中的按键?
@keyup/@keydown
后面还可以指定某一个按键才会触发事件
修饰符:

.enter
.tab
.delete(捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right
Vue2.1.0 +
.ctrl
.alt
.shift
.meta
9.vue-router有哪几种导航守卫?

router.beforeEach (路由改变之前触发)
router.beforeResolve(全局的和组件内的守卫都执行完毕, 最后再执行这个)
router.afterEach (守卫之后, 路由改变完成触发)
组件内守卫: (当前组件身上的守卫)

beforeRouteEnter (当前组件将要被路由加载前的一刻触发, 不能获取this, 因为组件DOM还没被加载)
beforeRouteUpdate(2.2 新增) (该组件被复用时调用)
beforeRouteLeave (导航路由离开该组件时触发)
vue-router实现路由懒加载（ 动态加载路由 ）
懒加载的使用场景:Vue打 包会变得非常大，影响页面加载速度。当路由被访问的时候才加载对应组件，这样就更加高效了。
懒加载步骤:
(1): 使用异步组件技术: (例: component: resolve => require(['@/components/home'],resolve)
(2): () => import('@/views/nested/menu1/menu1-2/menu1-2-1')
动态路由方案:
(1), 合并路由的配置项, (注意, 要使用异步加载)
(2): router.addRoutes(), 一般应用场景在不同用户给与不同的路由列表

11.Vuex在Vue-cli中的应用?

Vuex: 全局状态管理, 它是Vue官方推荐使用, 内部有主要state/mutations/actions/getters/modules, Store只能有一个
使用步骤: (1) 下载 (2) 引入并且配置 (3) main.js中注入全局store
使用场景: 当跨组件传值/跨页面传值/需要保存在全局的逻辑变量

Vue之间的传值方式?
页面-页面 (跳转传参, 路由的路径, path配合query, name配合parmas)
组件-组件 (父->子用props, 子->父 自定义事件, 跨组件 EventBus/Vuex)
还可以使用refs来直接操作子组件

13.Vue的双向数据绑定的原理?

使用数据观察+劫持+订阅观察者模式, 配合Object.defineProperty来监听每个属性的变化, 同时更新DOM标签

请说出vue.cli项目中src目录每个文件夹和文件的用法？
api ---- 接口管理封装
assets --- 打包的静态资源
components --- 复用的组件封装
icons ---- 字体图标文件
router ---- 路由配置
store ---- Vuex的配置
style ---- 全局样式
utils --- 工具包
pages/views --- 页面组件
directives --- 全局指令
filters ---- 全局过滤器
vertical --- 全局验证类
main.js --- 项目配置入口
App.Vue --- 根组件

为什么虚拟DOM会提高性能?
虚拟DOM其实就是一个JavaScript对象, 原理: createDocumentFragment()
在数据更新时, 只更新部分DOM结构
减少实际DOM的操作次数
如何封装一个组件, 谈谈你的思路?

改React的state属性时，会触发哪些生命周期钩子?
shouldComponentUpdate 如果返回true, 接着触发
componentWillUpdate 和 render 和 componentDidUpdate
补充: 如果是父向我传入的值, 还会触发子组件的componentWillReceiveProps

React 中 keys 的作用是什么?
Keys 是Diff算法中元素的Key值来判断哪些标签需要重新渲染,优化性能
注意同级元素唯一性key,

.>3. React构建组件的方法有几种?

React.createClass()的方式
构造函数的方法
class 集成 React.Component的方式

何让网络请求更快? / 如何让浏览器访问页面打开更块
目的: 优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。减少服务器被访问的资源, 客观减少成本
可参考: 雅虎35条军规:https://www.cnblogs.com/xianyulaodi/p/5755079.html
太多, 而且有的不太用的到的, 我分模块总结了一下, 包括过时的

文件加载部分

使用雪碧图 和 字体图标, 代替图片文件, 减少http请求次数
这是错误的, 因为现在HTTP协议1.1会复用之前的TCP链接, 当然前提需要后台支持才可以), 不会带来更多的开销 具体引用文章: https://segmentfault.com/a/1190000015665465
假如不支持复用, 合并也不要过分, 因为浏览器会并发执行http请求(注意每个浏览器并发的http请求数量也是不一样的)
图片尽量采用base64加载, 错误, base64会加大图片的所占体积
样式加载, 尽量和html在同一个文件内, 不要去拆分到不同的网站中, 不要使用iframe
代码部分

预加载/按需加载 -> 大量图片使用预加载方式, 每次多请求下一页的图片, 在内存中, 用户刷新可以马上显示.
减少DOM的操作
公共代码提取出来, 进行模块化开发, 避免代码被重复加载
用更少的代码, 开发出相同的功能
代码压缩, 语法混淆.
不要使用系统的弹窗, 阻塞页面
尽量不要使用eval
如果是框架, 可以考虑路由懒加载
减少监听器, 使用事件委托
css避免使用过滤器
缓存部分

用内存来保存值/cookie/storage, 如果变量值不存在, 再去服务器获取, 减少服务器压力, 提高前端页面加载速度
CDN加速, 让用户就近访问自己需要的资源, 加快响应速度
Ajax的get方式, 是可以缓存的
什么是CDN?
内容分发网络
CDN（Content Deliver Network）是一组分布在多个不同地理位置的Web服务器，通过将网站的资源发布到最接近用户的网络”边缘“，供用户就近取得所需内容。CDN可以看作一种缓存代理，主要用于对静态资源（如图片，css，js等）的缓存
AMD/CMD/CommonJS规范区别?
正常轮播图, 3图的轮播图
jwt  缓存   refulapi 事件循环node环境   for foreach效率   call (null/undefined情况)
$nextTick()执行机制
this在node后端的指向
vue 为啥用proxy 好处是啥?
react hook编程
redux 原理
vue 301 302的含义
各种web安全攻击


监听者观察者设计模式

call和apply 实现原理?

fetch的原理和使用

线上线下的npm 到底有啥区别?

手写vue-cli脚手架 

发布订阅模式  和 观察者模式 

null 和undefined 区别?
undefined是未指定值时, 没有显示返回值的函数, JS引擎都会为其分配undefined值

null是明确的给与的一个值, null 和 undefined 双等相等, 三等为false

&& 逻辑与, 找到第一个虚值表达式返回它, 如果没有找到, 返回最后的真值表达式
例如: " " && true && 5  此逻辑与表达式结果为5 而非true, 只不过在判断中会隐藏转换为true使用

JS中的虚值: '' 0 null undefined NaN false 隐式类型转换为false时的值
如何检测虚值, 用Boolean或者!!转换一下


如何最快的把数字字符串转成数字,  用+"123"  (+ - 是一元正负运算, 而不是+运算)

DOM是什么?
文档对象模型, 是HTML文件的API接口, 基于HTML标签的一个关系树结构组成了DOM的结构, 可以在这个关系树结构中, 进行增删改查操作, 也用很多API接口方法

! 可以把右侧的值强制转换成Boolean类型, 也可以用来取反

严格模式:
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能使用前缀 0 表示八进制数，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不能在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
增加了保留字（比如protected、static和interface）
设立”严格模式”的目的，主要有以下几个：

消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
消除代码运行的一些不安全之处，保证代码运行的安全；
提高编译器效率，增加运行速度；
为未来新版本的Javascript做好铺垫。

什么是函数式编程?
函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。

函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范示的其他示例也包括面向对象编程和过程编程。

函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。

什么是高阶函数?
高阶函数只是将函数作为参数或返回值的函数

手动实现 Array.prototype.map 方法

map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

function map(arr, mapCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
    return [];
  } else {
    let result = [];
    // 每次调用此函数时，我们都会创建一个 result 数组
    // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      result.push(mapCallback(arr[i], i, arr));
      // 将 mapCallback 返回的结果 push 到 result 数组中
    }
    return result;
  }
}
35. 手动实现Array.prototype.filter方法

filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。

function filter(arr, filterCallback) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function')
  {
    return [];
  } else {
    let result = [];
     // 每次调用此函数时，我们都会创建一个 result 数组
     // 因为我们不想改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      // 检查 filterCallback 的返回值是否是真值
      if (filterCallback(arr[i], i, arr)) {
      // 如果条件为真，则将数组元素 push 到 result 中
        result.push(arr[i]);
      }
    }
    return result; // return the result array
  }
}
36. 手动实现Array.prototype.reduce方法

reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。

function reduce(arr, reduceCallback, initialValue) {
  // 首先，检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function')
  {
    return [];
  } else {
    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue
    let hasInitialValue = initialValue !== undefined;
    let value = hasInitialValue ? initialValue : arr[0];
   、

    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始
    for (let i = hasInitialValue ? 0 : 1, len = arr.length; i < len; i++) {
      value = reduceCallback(value, arr[i], i, arr);
    }
    return value;
  }
}


如何创建一个没有原型的对象, 用Object.create()

ES6新特性:
箭头函数
类
模板字符串
加强的对象字面量
对象解构
Promise
生成器
模块
Symbol
代理
Set
函数默认参数
rest 和展开
块作用域

为什么在 JS 中比较两个相似的对象时返回 false？
先看下面的例子：

let a = { a: 1 };
let b = { a: 1 };
let c = a;

console.log(a === b); // 打印 false，即使它们有相同的属性
console.log(a === c); // true
JS 以不同的方式比较对象和基本类型。在基本类型中，JS 通过值对它们进行比较，而在对象中，JS 通过引用或存储变量的内存中的地址对它们进行比较。这就是为什么第一个console.log语句返回false，而第二个console.log语句返回true。a和c有相同的引用地址，而a和b没有。


什么是提升?
提升是用来描述变量和函数移动到其(全局或函数)作用域顶部的术语。

为了理解提升，需要来了解一下执行上下文。执行上下文是当前正在执行的“代码环境”。执行上下文有两个阶段:编译和执行。

编译-在此阶段，JS 引荐获取所有函数声明并将其提升到其作用域的顶部，以便我们稍后可以引用它们并获取所有变量声明（使用var关键字进行声明），还会为它们提供默认值： undefined。

执行——在这个阶段中，它将值赋给之前提升的变量，并执行或调用函数(对象中的方法)。

注意:只有使用var声明的变量，或者函数声明才会被提升，相反，函数表达式或箭头函数，let和const声明的变量，这些都不会被提升。

假设在全局使用域，有如下的代码：

console.log(y);
y = 1;
console.log(y);
console.log(greet("Mark"));

function greet(name){
  return 'Hello ' + name + '!';
}

var y;
上面分别打印：undefined,1, Hello Mark!。

上面代码在编译阶段其实是这样的：

function greet(name) {
  return 'Hello ' + name + '!';
}

var y; // 默认值 undefined

// 等待“编译”阶段完成，然后开始“执行”阶段

/*
console.log(y);
y = 1;
console.log(y);
console.log(greet("Mark"));
*/
编译阶段完成后，它将启动执行阶段调用方法，并将值分配给变量。

function greet(name) {
  return 'Hello ' + name + '!';
}

var y;

//start "execution" phase

console.log(y);
y = 1;
console.log(y);
console.log(greet("Mark"));

什么是作用域?
JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：全局作用域、函数作用域和块作用域(ES6)。

全局作用域——在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方都可以访问它们。

//global namespace
var g = "global";

function globalFunc(){
  function innerFunc(){
    console.log(g); // can access "g" because "g" is a global variable
  }
 innerFunc();
}
函数作用域——在函数中声明的变量、函数和参数可以在函数内部访问，但不能在函数外部访问。

function myFavoriteFunc(a) {
  if (true) {
    var b = "Hello " + a;
  }
  return b;
}

myFavoriteFunc("World");

console.log(a); // Throws a ReferenceError "a" is not defined
console.log(b); // does not continue here
块作用域-在块{}中声明的变量（let，const）只能在其中访问。

 function testBlock(){
   if(true){
     let z = 5;
   }
   return z;
 }

 testBlock(); // Throws a ReferenceError "z" is not defined
作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为作用域链。

   /* 作用域链
     
     内部作用域->外部作用域-> 全局作用域
  */

  // 全局作用域
  var variable1 = "Comrades";
  var variable2 = "Sayonara";

  function outer(){
  // 外部作用域
    var variable1 = "World";
    function inner(){
    // 内部作用域
      var variable2 = "Hello";
      console.log(variable2 + " " + variable1);
    }
    inner();
  }
  outer(); // Hello World


  Promise 是什么？
Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。promise有三种状态：pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。

什么是 async/await 及其如何工作？
async/await是 JS 中编写异步或非阻塞代码的新方法。它建立在Promises之上，让异步代码的可读性和简洁度都更高。

async/await是 JS 中编写异步或非阻塞代码的新方法。它建立在Promises之上，相对于 Promise 和回调，它的可读性和简洁度都更高。但是，在使用此功能之前，我们必须先学习Promises的基础知识，因为正如我之前所说，它是基于Promise构建的，这意味着幕后使用仍然是Promise

 展开(spread )运算符和 剩余(Rest) 运算符有什么区别？
展开运算符(spread)是三个点(...)，可以将一个数组转为用逗号分隔的参数序列。说的通俗易懂点，有点像化骨绵掌，把一个大元素给打散成一个个单独的小元素。

剩余运算符也是用三个点(...)表示，它的样子看起来和展开操作符一样，但是它是用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。

什么是包装对象（wrapper object）？
我们现在复习一下JS的数据类型，JS数据类型被分为两大类，基本类型和引用类型。

基本类型：Undefined,Null,Boolean,Number,String,Symbol,BigInt

引用类型：Object,Array,Date,RegExp等，说白了就是对象。

其中引用类型有方法和属性，但是基本类型是没有的，但我们经常会看到下面的代码：

let name = "marko";

console.log(typeof name); // "string"
console.log(name.toUpperCase()); // "MARKO"
name类型是 string，属于基本类型，所以它没有属性和方法，但是在这个例子中，我们调用了一个toUpperCase()方法，它不会抛出错误，还返回了对象的变量值。

原因是基本类型的值被临时转换或强制转换为对象，因此name变量的行为类似于对象。除null和undefined之外的每个基本类型都有自己包装对象。也就是：String，Number，Boolean，Symbol和BigInt。在这种情况下，name.toUpperCase()在幕后看起来如下：

console.log(new String(name).toUpperCase()); // "MARKO"
在完成访问属性或调用方法之后，新创建的对象将立即被丢弃。


如何在不使用%模运算符的情况下检查一个数字是否是偶数？
我们可以对这个问题使用按位&运算符，&对其操作数进行运算，并将其视为二进制值，然后执行与运算。

function isEven(num) {
  if (num & 1) {
    return false
  } else {
    return true
  }
}
0 二进制数是 000
1 二进制数是 001
2 二进制数是 010
3 二进制数是 011
4 二进制数是 100
5 二进制数是 101
6 二进制数是 110
7 二进制数是 111

以此类推...

与运算的规则如下：

a	b	a & b
0	0	0
0	1	0
1	1	1
因此，当我们执行console.log(5&1)这个表达式时，结果为1。首先，&运算符将两个数字都转换为二进制，因此5变为101，1变为001。


如何检查对象中是否存在某个属性？
检查对象中是否存在属性有三种方法。

第一种使用 in 操作符号：

const o = {
  "prop" : "bwahahah",
  "prop2" : "hweasa"
};

console.log("prop" in o); // true
console.log("prop1" in o); // false
第二种使用 hasOwnProperty 方法，hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。

console.log(o.hasOwnProperty("prop2")); // true
console.log(o.hasOwnProperty("prop1")); // false
第三种使用括号符号obj["prop"]。如果属性存在，它将返回该属性的值，否则将返回undefined。

console.log(o["prop"]); // "bwahahah"
console.log(o["prop1"]); // undefined


in 运算符和 Object.hasOwnProperty 方法有什么区别？
如你所知，这两个特性都检查对象中是否存在属性，它将返回truefalse。它们之间的区别在于，in操作符还会检查对象的原型链，如果属性在当前对象中没有找到，而hasOwnProperty方法只检查属性是否存在于当前对象中，而忽略原型链。

hasOwnPropert方法

hasOwnPropert()方法返回值是一个布尔值，指示对象自身属性中是否具有指定的属性，因此这个方法会忽略掉那些从原型链上继承到的属性。

看下面的例子：

Object.prototype.phone= '15345025546';

let obj = {
    name: '西门大官人',
    age: '28'
}
console.log(obj.hasOwnProperty('phone')) // false
console.log(obj.hasOwnProperty('name')) // true
可以看到，如果在函数原型上定义一个变量phone，hasOwnProperty方法会直接忽略掉。

in 运算符

如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。

还是用上面的例子来演示：

console.log('phone' in obj) // true
可以看到in运算符会检查它或者其原型链是否包含具有指定名称的属性。

什么是缓存及它有什么作用？
缓存是建立一个函数的过程，这个函数能够记住之前计算的结果或值。使用缓存函数是为了避免在最后一次使用相同参数的计算中已经执行的函数的计算。这节省了时间，但也有不利的一面，即我们将消耗更多的内存来保存以前的结果。

68. 手动实现缓存方法
function memoize(fn) {
    const cache = {};
    return function (param) {
    if (cache[param]) {
      console.log('cached');
      return cache[param];
    } else {
      let result = fn(param);
      cache[param] = result;
      console.log(`not cached`);
      return result;
    }
    }
}

const toUpper = (str ="")=> str.toUpperCase();

const toUpperMemoized = memoize(toUpper);

toUpperMemoized("abcdef");
toUpperMemoized("abcdef");
这个缓存函数适用于接受一个参数。我们需要改变下，让它接受多个参数。

const slice = Array.prototype.slice;
function memoize(fn) {
  const cache = {};
  return (...args) => {
    const params = slice.call(args);
    console.log(params);
    if (cache[params]) {
      console.log('cached');
      return cache[params];
    } else {
      let result = fn(...args);
      cache[params] = result;
      console.log(`not cached`);
      return result;
    }
  }
}
const makeFullName = (fName, lName) => `${fName} ${lName}`;
const reduceAdd = (numbers, startingValue = 0) =>
 numbers.reduce((total, cur) => total + cur, startingValue);

const memoizedMakeFullName = memoize(makeFullName);
const memoizedReduceAdd = memoize(reduceAdd);

memoizedMakeFullName("Marko", "Polo");
memoizedMakeFullName("Marko", "Polo");

memoizedReduceAdd([1, 2, 3, 4, 5], 5);
memoizedReduceAdd([1, 2, 3, 4, 5], 5);


