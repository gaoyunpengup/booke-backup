## 正向代理
通过一个代理服务器, 完成我们想要进行的请求, 也是翻墙最简单的理解:
![](/server/screenshot_1556768586174.png)
### 模拟一个正向代理
#### 准备
1. 客户端A(本机浏览器)
2. 代理服务器B(暂时本地: Ngnix)
3. 目标资源C(一个网页, 或url)
> 如果你会vue的proxy代理转发, 那就更好理解这里了, 互通的
#### 开始
抛出问题: 我们现在访问www.lidongxu.com, 是访问不到的(假设地址是国外) <br>
![](/server/Snipaste_2020-04-11_16-34-44.png)  <br>
这时, 找一个可以访问此网站的中间代理服务器B(一般都假设在台湾/香港的服务器, 需要花钱购买的), 这里使用本地的nginx模拟 <br>
1. 本机hosts文件中配置本地访问规则 (hosts设置访问的域名会被重定向到哪里, 也可以屏蔽一些少儿不宜的网站哦(前提知道域名)) <br>
> 可以把左边127.0.0.1改成你真实的中间代理服务器B的ip地址, 让本地的请求转发到目标ip地址上 <br>

![](/server/screenshot_1556775742636.png)
2. 代理服务器B, nginx配置规则 <br>
   server_name 监听客户端要请求的域名 <br>
   face.html 也可以配置成国外的目标地址(这里不做梯子教程, 用个网页模拟吧) <br>
   ![](/server/screenshot_1556775888071.png)
3. 在浏览器访问www.lidongxu.com:8080 即可
   ![](/server/screenshot_1556775922499.png)

## 反向代理
客户端不知道业务服务器具体ip, 而是知道nginx的地址, 由nginx进行代理分配给具体业务服务器, 反向隐藏了具体业务服务器
![](/server/screenshot_1556778459228.png)
### 模拟一个反向代理
#### 准备
没有具体的第二台服务器, 把nginx利用2个端口区分成2个服务器
1. 客户端A(本机浏览器)
2. NginxA(:8080端口)
3. NginxB(:80端口)
#### 开始
1. 配置客户端A的hosts配置
![](/server/screenshot_1556778676952.png)
2. 配置NginxA反向代理规则
![](/server/screenshot_1556778697208.png)
> 当客户端访问www.fandai.com:8080时, 反向代理给真实ip:80的url
3. 配置NginxB业务服务器80端口的处理
![](/server/screenshot_1556778757401.png) <br>
4. 运行后的效果查看
![](/server/screenshot_1556778775055.png)
## 负载均衡
1. 将服务器接收到的请求按照规则分发的过程，称为负载均衡
![](/server/screenshot_1556856907472.png)
2. 常用的方式有如下几种
   * weight轮询（默认）: 接收的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响
   * ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题
   * fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高, nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块
   *  url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包



